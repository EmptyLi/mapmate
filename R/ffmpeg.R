#' Make video from still image sequence
#'
#' Make a video file from a sequence of still images using FFmpeg.
#'
#' \code{ffmpeg} is a wrapper function around the popular FFmpeg command line multimedia framework.
#' It translates arguments provided by the user in familiar R syntax into a system call to the \code{ffmpeg} command line tool, which must be installed on the system.
#'
#' \code{ffmpeg} does not provide complete flexibility to allow making every possible valid call to FFmpeg,
#' but users who are that well versed in the use of FFmpeg can use the command line utility directly or pass their custom calls directly to \code{system} from within R.
#' The \code{ffmpeg} R function is primarily useful to users not well versed in the use of the FFmpeg multimedia framework who will be satisfied with the level of flexibility provided.
#' Since this function is provided in the context of the \code{mapmate} package, it is aimed at assisting with converting still image sequences to video.
#' While additional uses may be incorporated into \code{ffmpeg} in future, the FFmpeg multimedia framework itself provides a far broader suite of tools and functionality than is needed here.
#'
#' A common way to specify a set of input image files when using FFmpeg directy is to provide something like \code{myimages%04d.png},
#' which requires specifying the entire, non-changing file name with the only substitution being for the unique, order, consecutive integer file numbering component of the file name.
#' The pattern used indicates how may places are occupied by the file indices, which should be constant. In this example, \code{%04d} represents the file numbering \code{0000, 0001, 0002, ..., 9999}.
#' If using Windows, you must use this approach. Any image sequences generated by \code{mapmate} will follow this kind of file naming convention.
#' If you want to make videos from image sequences not made by \code{mapmate}, they will also commonly follow this convention, but not always, in which case you will have to rename your files.
#'
#' An alternative and often convenient way to provide a general pattern for matching to a set of input files is with globbing. However, globbing is not available on Windows.
#' Linux users may find this additional option helpful in cases where file naming is not quite as described above or, for example, if there are multiple sequences of files in one directory.
#' If \code{glob=TRUE}, wildcards can be used in the \code{pattern} argument, e.g., \code{pattern="*png"}, \code{pattern="myimages*png"}, or \code{pattern="*images0*.png"}.
#' The default is \code{glob=FALSE} and \code{glob} is simply ignored on Windows.
#'
#' @param dir directory containing images, defaults to working directory.
#' @param pattern character, for matching a set of input image files. See details for acceptable and possible alternative patterns.
#' @param glob logical, defaults to \code{FALSE}. Globbing is not available on Windows. Linux users, see details on how \code{glob} affects \code{pattern}.
#' @param codec character, the video codec used. See details.
#' @param start integer, frame to start from in input image sequence. Defaults to \code{start=1}.
#' Set to zero if your image sequence has file names beginning from zero or a higher number if you want to skip frames.
#' @param output character, output file name.
#' @param output_dir character, output directory. Defaults to working directory.
#' @param rate numeric, framerate of output video in Hz.
#' @param delay numeric, time delay between frames in output video. Alternative to \code{rate}. \eqn{delay=1/rate}.
#' @param overwrite logical, overwrite existing output file.
#'
#' @return returns the system call to FFmpeg as a character string.
#' @export
#'
#' @examples
ffmpeg <- function(dir=".", pattern, output, output_dir=".", rate=30, delay=1/rate, codec="h264", start=1, overwrite=FALSE, glob=FALSE){
  if (!missing(rate) && !missing(delay)) stop("specify 'rate' or 'delay' but not both")
  if(!missing(delay)) rate <- 1/delay
  rate <- paste("-r", rate)

  # input files
  linux <- .Platform$OS.type=="linux"
  iglob <- "-pattern_type glob -i "
  input <- file.path(dir, pattern)
  input <- ifelse(linux & glob, paste0(iglob, "'", input, "'"), paste("-i", input))
  input <- paste("-start_number", start, input)

  #output files
  output <- file.path(output_dir, output)

  output <- paste(output, rate, ifelse(overwrite, "-y", "-n"))

  #video codec
  vc <- paste("-c:v", codec)

  x <- paste("ffmpeg", input, vc, output)
  details <- capture.output(system(x))
  x
}
