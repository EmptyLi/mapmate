% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{gc_paths}
\alias{gc_paths}
\title{Generate a table of incremental great circle arc segments}
\usage{
gc_paths(data, size, replicates = 1, direction = "fixed", max.offset = 0)
}
\arguments{
\item{data}{a data frame.}

\item{size}{integer, the maximum number of points used to define a great circle arc segment.}

\item{replicates}{integer, the number of replicates of an arc. Defaults to \code{1}.}

\item{direction}{character. Defaults to \code{fixed}.}

\item{max.offset}{integer, maximum allowable offset for the plot frame on which great circle arc path traversal commences.}
}
\value{
a data frame.
}
\description{
Expand a table of great circle arcs to a larger table of great circle arc segments that sequentially traverse the original arcs.
}
\details{
\code{gc_paths} takes a data frame as generated by \code{gc_arcs} and breaks each set of points defining each arc
into a sequence of points defining arc segments that cover the entire original arc in order from one endpoint to the other.
Segments along the path that covers an arc may overlap to varying degrees based on the segment size, which is variable.

\code{size} describes the maximum number of points composing a great circle arc segment.
It must be at least \code{2} and is used to sample integers uniformly between \eqn{[2, size]}.
This defines the range of values from which the actual segment length is sampled. There are not any other options in the current package version for specifying segment lengths.
Length is also fixed across all segments in a given arc, but is allowed to vary between arcs.

\code{replicates} simply duplicates a sequence of segments for a given arc, which are then allowed to commence path traversal during unique plot frames
based on \code{max.offset}. For example, if \code{replicates=2} and \code{max.offset=2},
two instances of the same arc segment path sequence for a specific arc can begin on plot frames \code{0}, \code{1}, or \code{2}.
\code{max.offset} must be at least \code{replicates - 1}.

For \code{direction="fixed"}, no change are made to \code{data}.
\code{direction="reverse"} will switch the order of the points in the arc and \code{direction="random"} gives a probability of 0.5 that order is reversed.
This is useful in the context of applying \code{gc_paths} over multiple great circle arcs as well as for simulations.

In the context of animating a sequence of plot frames, and holding other factors constant,
the general rule of thumb is animations will appear to traverse the path of longer great circle arcs with greater speed than of shorter great circle arcs,
taking about the same amount of time (number of frames) to complete the journey from endpoint to endpoint because each arc is composed of the same number of points.
On the other hand, the more points an arc consists of, the slower it will be traversed.
Another factor is the length of each segment along the path of the arc and how much each successive segment is allowed to overlap the previous one from one plot to the next.
See \code{gc_arcs} regarding generating great circle arcs composed of varying numbers of points.

Overall, there is an interplay between the number of points composing an entire arc, the segment length (number of points composing the successive subsets of an arc),
and degree of segment overlap (how the arc is broken into segments to trace the path along the arc).
Longer segments made up of more points means the arc is traversed more quickly.
More segment overlap will slow down the journey.
More points composing the entire arc shrinks the distance covered by each segment.
}
\examples{
set.seed(192)
data(network)
distFun <- function(x) 1 - x / max(x) # simple inverse distance weighting
endpoints <- gc_endpoints(network, "lon", "lat")
endpoints <- mutate(endpoints, Dist_wts=distFun(Dist))

# take a weighted sample, e.g., favoring larger averaged populations and shorter distances
endpoints <- sample_n(500, replace=TRUE, weight=(Pop_wts0 + Pop_wts1)/2 + Dist_wts)

# expand data frame from endpoints to arcs, each composed of a sequence of points
arcs <- gc_arcs(endpoints, "lon0", "lat0", "lon1", "lat1")

paths <- gc_paths(arcs, size=5)
}

